--- module-dvbapi.c	2017-02-18 21:08:17.000000000 +1000
+++ module-dvbapi.c	2017-02-19 17:08:35.613757657 +1000
@@ -5755,45 +5770,59 @@ static void *dvbapi_main_local(void *cli
 	return NULL;
 }
 
-void dvbapi_write_cw(int32_t demux_id, uchar *cw, int32_t pid, int32_t stream_id, enum ca_descr_algo algo, enum ca_descr_cipher_mode cipher_mode)
+void dvbapi_write_cw(int32_t demux_id, uchar *cw, int8_t cw_aes, int32_t pid, int32_t stream_id, enum ca_descr_algo algo, enum ca_descr_cipher_mode cipher_mode)
 {
 	int32_t n;
 	int8_t cwEmpty = 0;
-	unsigned char nullcw[8];
-	memset(nullcw, 0, 8);
+	unsigned char nullcw[16];
+	memset(nullcw, 0, 16);
 	ca_descr_t ca_descr;
+	ca_descr_aes_t ca_descr_aes;
 	ca_descr_mode_t ca_descr_mode;
 
 	memset(&ca_descr, 0, sizeof(ca_descr));
+	memset(&ca_descr_aes, 0, sizeof(ca_descr_aes));
 	memset(&ca_descr_mode, 0, sizeof(ca_descr_mode_t));
 	
-	if(memcmp(demux[demux_id].lastcw[0], nullcw, 8) == 0
-			&& memcmp(demux[demux_id].lastcw[1], nullcw, 8) == 0)
+	if(memcmp(demux[demux_id].lastcw[0], nullcw, cw_aes ? 16 : 8) == 0
+			&& memcmp(demux[demux_id].lastcw[1], nullcw, cw_aes ? 16 : 8) == 0)
 		{ cwEmpty = 1; } // to make sure that both cws get written on constantcw
 
 
 	for(n = 0; n < 2; n++)
 	{
-		char lastcw[9 * 3];
-		char newcw[9 * 3];
-		cs_hexdump(0, demux[demux_id].lastcw[n], 8, lastcw, sizeof(lastcw));
-		cs_hexdump(0, cw + (n * 8), 8, newcw, sizeof(newcw));
+		char lastcw[18 * 3];
+		char newcw[18 * 3];
+		cs_hexdump(0, demux[demux_id].lastcw[n], cw_aes ? 16 : 8, lastcw, sizeof(lastcw));
+		cs_hexdump(0, cw + (n * cw_aes ? 16 : 8), cw_aes ? 16 : 8, newcw, sizeof(newcw));
 
 		// check if already delivered and new cw part is valid but dont check for nullcw on Biss
-		if((memcmp(cw + (n * 8), demux[demux_id].lastcw[n], 8) != 0 || cwEmpty || stream_id >1)
-			&& (memcmp(cw + (n * 8), nullcw, 8) != 0 || demux[demux_id].ECMpids[pid].CAID == 0x2600))
+		if((memcmp(cw + (n * cw_aes ? 16 : 8), demux[demux_id].lastcw[n], cw_aes ? 16 : 8) != 0 || cwEmpty || stream_id >1)
+			&& (memcmp(cw + (n * cw_aes ? 16 : 8), nullcw, cw_aes ? 16 : 8) != 0 || demux[demux_id].ECMpids[pid].CAID == 0x2600))
 		{
 			ca_index_t idx = dvbapi_ca_setpid(demux_id, pid, stream_id, (algo == CA_ALGO_DES));  // prepare ca
 			if (idx == INDEX_INVALID) return; // return on no index!
 
 #if defined WITH_COOLAPI || defined WITH_COOLAPI2
 			ca_descr_mode.cipher_mode = cipher_mode;
-			ca_descr.index = idx;
-			ca_descr.parity = n;
-			memcpy(demux[demux_id].lastcw[n], cw + (n * 8), 8);
-			memcpy(ca_descr.cw, cw + (n * 8), 8);
-			cs_log_dbg(D_DVBAPI, "Demuxer %d write cw%d index: %d (ca_mask %d)", demux_id, n, ca_descr.index, demux[demux_id].ca_mask);
-			coolapi_write_cw(demux[demux_id].ca_mask, demux[demux_id].STREAMpids, demux[demux_id].STREAMpidcount, &ca_descr);
+			if(cw_aes)
+			{
+				ca_descr_aes.index = idx;
+				ca_descr_aes.parity = n;
+				memcpy(demux[demux_id].lastcw[n], cw + (n * 16), 16);
+				memcpy(ca_descr_aes.cw, cw + (n * 16), 16);
+				cs_log_dbg(D_DVBAPI, "Demuxer %d write cw%d index: %d (ca_mask %d)", demux_id, n, ca_descr_aes.index, demux[demux_id].ca_mask);
+				coolapi_write_cw(demux[demux_id].ca_mask, demux[demux_id].STREAMpids, demux[demux_id].STREAMpidcount, &ca_descr_aes);
+			}
+			else
+			{
+				ca_descr.index = idx;
+				ca_descr.parity = n;
+				memcpy(demux[demux_id].lastcw[n], cw + (n * 8), 8);
+				memcpy(ca_descr.cw, cw + (n * 8), 8);
+				cs_log_dbg(D_DVBAPI, "Demuxer %d write cw%d index: %d (ca_mask %d)", demux_id, n, ca_descr.index, demux[demux_id].ca_mask);
+				coolapi_write_cw(demux[demux_id].ca_mask, demux[demux_id].STREAMpids, demux[demux_id].STREAMpidcount, &ca_descr);
+			}
 #else
 			int32_t i, j, write_cw = 0;
 			ca_index_t usedidx, lastidx;
@@ -5834,15 +5863,29 @@ void dvbapi_write_cw(int32_t demux_id, u
 					if(!write_cw) { continue; } // no need to write the cw since this ca isnt using it!
 					
 					lastidx = usedidx;
-					ca_descr.index = usedidx;
-					ca_descr.parity = n;
-					memcpy(demux[demux_id].lastcw[n], cw + (n * 8), 8);
-					memcpy(ca_descr.cw, cw + (n * 8), 8);
-					cs_log_dbg(D_DVBAPI, "Demuxer %d writing %s part (%s) of controlword, replacing expired (%s)", demux_id, (n == 1 ? "even" : "odd"), newcw, lastcw);
-					cs_log_dbg(D_DVBAPI, "Demuxer %d write cw%d index: %d (ca%d)", demux_id, n, ca_descr.index, i);
-					
+					if(cw_aes)
+					{
+						ca_descr_aes.index = usedidx;
+						ca_descr_aes.parity = n;
+						memcpy(demux[demux_id].lastcw[n], cw + (n * 16), 16);
+						memcpy(ca_descr_aes.cw, cw + (n * 16), 16);
+						cs_log_dbg(D_DVBAPI, "Demuxer %d writing %s part (%s) of controlword, replacing expired (%s)", demux_id, (n == 1 ? "even" : "odd"), newcw, lastcw);
+						cs_log_dbg(D_DVBAPI, "Demuxer %d write cw%d index: %d (ca%d)", demux_id, n, ca_descr_aes.index, i);
+					}
+					else
+					{
+						ca_descr.index = usedidx;
+						ca_descr.parity = n;
+						memcpy(demux[demux_id].lastcw[n], cw + (n * 8), 8);
+						memcpy(ca_descr.cw, cw + (n * 8), 8);
+						cs_log_dbg(D_DVBAPI, "Demuxer %d writing %s part (%s) of controlword, replacing expired (%s)", demux_id, (n == 1 ? "even" : "odd"), newcw, lastcw);
+						cs_log_dbg(D_DVBAPI, "Demuxer %d write cw%d index: %d (ca%d)", demux_id, n, ca_descr.index, i);
+					}
 					if(cfg.dvbapi_boxtype == BOXTYPE_PC || cfg.dvbapi_boxtype == BOXTYPE_PC_NODMX)
-						dvbapi_net_send(DVBAPI_CA_SET_DESCR, demux[demux_id].socket_fd, demux_id, -1 /*unused*/, (unsigned char *) &ca_descr, NULL, NULL, demux[demux_id].client_proto_version);
+						if(cw_aes)
+							dvbapi_net_send(DVBAPI_CA_SET_DESCR_AES, demux[demux_id].socket_fd, demux_id, -1 /*unused*/, (unsigned char *) &ca_descr_aes, NULL, NULL, demux[demux_id].client_proto_version);
+						else
+							dvbapi_net_send(DVBAPI_CA_SET_DESCR, demux[demux_id].socket_fd, demux_id, -1 /*unused*/, (unsigned char *) &ca_descr, NULL, NULL, demux[demux_id].client_proto_version);
 					else
 					{
 						if(ca_fd[i] <= 0)
@@ -6253,17 +6306,17 @@ void dvbapi_send_dcw(struct s_client *cl
 							cw = er->cw_ex.data;
 						}
 						
-						dvbapi_write_cw(i, cw, j, k, er->cw_ex.algo, er->cw_ex.algo_mode);
+						dvbapi_write_cw(i, cw, er->cw_aes, j, k, er->cw_ex.algo, er->cw_ex.algo_mode);
 					}
 				}
 				else
 				{
 					demux[i].ECMpids[j].useMultipleIndices = 0;
-					dvbapi_write_cw(i, er->cw, j, 0, er->cw_ex.algo, er->cw_ex.algo_mode);
+					dvbapi_write_cw(i, er->cw, er->cw_aes, j, 0, er->cw_ex.algo, er->cw_ex.algo_mode);
 				}
 #else
 				cfg.dvbapi_extended_cw_api = 0; // in CSA mode extended_cw_api should be always 0 regardless what user selected!  
-				dvbapi_write_cw(i, er->cw, j, 0, CA_ALGO_DVBCSA, CA_MODE_ECB);
+				dvbapi_write_cw(i, er->cw, er->cw_aes, j, 0, CA_ALGO_DVBCSA, CA_MODE_ECB);
 #endif
 				break;
 			}
@@ -6739,8 +6792,8 @@ int32_t dvbapi_check_ecm_delayed_deliver
 {
 	int32_t ret = 0;
 	int32_t filternum = dvbapi_get_filternum(demux_index, er, TYPE_ECM);
-	char nullcw[CS_ECMSTORESIZE];
-	memset(nullcw, 0, CS_ECMSTORESIZE);
+	char nullcw[CS_ECMSTORESIZE *2];
+	memset(nullcw, 0, CS_ECMSTORESIZE * 2);
 	
 	if(filternum < 0) { return 2; }  // if no matching filter act like ecm response is delayed
 	if(memcmp(demux[demux_index].demux_fd[filternum].lastecmd5, nullcw, CS_ECMSTORESIZE))
